// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package lss

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// LotsizeSolutionStoreClient is the client API for LotsizeSolutionStore service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LotsizeSolutionStoreClient interface {
	// Problem/Solution management
	ReadProblem(ctx context.Context, in *ReadProblemRequest, opts ...grpc.CallOption) (*ProblemIdentifier, error)
	CreateSolution(ctx context.Context, in *ProblemIdentifier, opts ...grpc.CallOption) (*ProblemEntityIdentifier, error)
	// Solution Improvement
	GetProblem(ctx context.Context, in *ProblemIdentifier, opts ...grpc.CallOption) (*Problem, error)
	GetMachine(ctx context.Context, in *ProblemEntityIdentifier, opts ...grpc.CallOption) (*Machine, error)
	GetDemandsForBucket(ctx context.Context, in *ProblemBucketIdentifier, opts ...grpc.CallOption) (LotsizeSolutionStore_GetDemandsForBucketClient, error)
	GetSolutionsIDsList(ctx context.Context, in *ProblemIdentifier, opts ...grpc.CallOption) (*IDsList, error)
	GetSolution(ctx context.Context, in *ProblemEntityIdentifier, opts ...grpc.CallOption) (LotsizeSolutionStore_GetSolutionClient, error)
	SolutionImprovementStart(ctx context.Context, in *ProblemEntityIdentifier, opts ...grpc.CallOption) (*SolutionEntityIdentifier, error)
	SolutionImprovementColsAdded(ctx context.Context, in *SolutionEntityIdentifier, opts ...grpc.CallOption) (*Int32Result, error)
	SolutionImprovementStop(ctx context.Context, in *SolutionEntityIdentifier, opts ...grpc.CallOption) (*Int32Result, error)
}

type lotsizeSolutionStoreClient struct {
	cc grpc.ClientConnInterface
}

func NewLotsizeSolutionStoreClient(cc grpc.ClientConnInterface) LotsizeSolutionStoreClient {
	return &lotsizeSolutionStoreClient{cc}
}

func (c *lotsizeSolutionStoreClient) ReadProblem(ctx context.Context, in *ReadProblemRequest, opts ...grpc.CallOption) (*ProblemIdentifier, error) {
	out := new(ProblemIdentifier)
	err := c.cc.Invoke(ctx, "/lsxcg.lss.LotsizeSolutionStore/ReadProblem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lotsizeSolutionStoreClient) CreateSolution(ctx context.Context, in *ProblemIdentifier, opts ...grpc.CallOption) (*ProblemEntityIdentifier, error) {
	out := new(ProblemEntityIdentifier)
	err := c.cc.Invoke(ctx, "/lsxcg.lss.LotsizeSolutionStore/CreateSolution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lotsizeSolutionStoreClient) GetProblem(ctx context.Context, in *ProblemIdentifier, opts ...grpc.CallOption) (*Problem, error) {
	out := new(Problem)
	err := c.cc.Invoke(ctx, "/lsxcg.lss.LotsizeSolutionStore/GetProblem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lotsizeSolutionStoreClient) GetMachine(ctx context.Context, in *ProblemEntityIdentifier, opts ...grpc.CallOption) (*Machine, error) {
	out := new(Machine)
	err := c.cc.Invoke(ctx, "/lsxcg.lss.LotsizeSolutionStore/GetMachine", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lotsizeSolutionStoreClient) GetDemandsForBucket(ctx context.Context, in *ProblemBucketIdentifier, opts ...grpc.CallOption) (LotsizeSolutionStore_GetDemandsForBucketClient, error) {
	stream, err := c.cc.NewStream(ctx, &LotsizeSolutionStore_ServiceDesc.Streams[0], "/lsxcg.lss.LotsizeSolutionStore/GetDemandsForBucket", opts...)
	if err != nil {
		return nil, err
	}
	x := &lotsizeSolutionStoreGetDemandsForBucketClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type LotsizeSolutionStore_GetDemandsForBucketClient interface {
	Recv() (*Demand, error)
	grpc.ClientStream
}

type lotsizeSolutionStoreGetDemandsForBucketClient struct {
	grpc.ClientStream
}

func (x *lotsizeSolutionStoreGetDemandsForBucketClient) Recv() (*Demand, error) {
	m := new(Demand)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *lotsizeSolutionStoreClient) GetSolutionsIDsList(ctx context.Context, in *ProblemIdentifier, opts ...grpc.CallOption) (*IDsList, error) {
	out := new(IDsList)
	err := c.cc.Invoke(ctx, "/lsxcg.lss.LotsizeSolutionStore/GetSolutionsIDsList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lotsizeSolutionStoreClient) GetSolution(ctx context.Context, in *ProblemEntityIdentifier, opts ...grpc.CallOption) (LotsizeSolutionStore_GetSolutionClient, error) {
	stream, err := c.cc.NewStream(ctx, &LotsizeSolutionStore_ServiceDesc.Streams[1], "/lsxcg.lss.LotsizeSolutionStore/GetSolution", opts...)
	if err != nil {
		return nil, err
	}
	x := &lotsizeSolutionStoreGetSolutionClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type LotsizeSolutionStore_GetSolutionClient interface {
	Recv() (*Column, error)
	grpc.ClientStream
}

type lotsizeSolutionStoreGetSolutionClient struct {
	grpc.ClientStream
}

func (x *lotsizeSolutionStoreGetSolutionClient) Recv() (*Column, error) {
	m := new(Column)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *lotsizeSolutionStoreClient) SolutionImprovementStart(ctx context.Context, in *ProblemEntityIdentifier, opts ...grpc.CallOption) (*SolutionEntityIdentifier, error) {
	out := new(SolutionEntityIdentifier)
	err := c.cc.Invoke(ctx, "/lsxcg.lss.LotsizeSolutionStore/SolutionImprovementStart", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lotsizeSolutionStoreClient) SolutionImprovementColsAdded(ctx context.Context, in *SolutionEntityIdentifier, opts ...grpc.CallOption) (*Int32Result, error) {
	out := new(Int32Result)
	err := c.cc.Invoke(ctx, "/lsxcg.lss.LotsizeSolutionStore/SolutionImprovementColsAdded", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lotsizeSolutionStoreClient) SolutionImprovementStop(ctx context.Context, in *SolutionEntityIdentifier, opts ...grpc.CallOption) (*Int32Result, error) {
	out := new(Int32Result)
	err := c.cc.Invoke(ctx, "/lsxcg.lss.LotsizeSolutionStore/SolutionImprovementStop", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LotsizeSolutionStoreServer is the server API for LotsizeSolutionStore service.
// All implementations must embed UnimplementedLotsizeSolutionStoreServer
// for forward compatibility
type LotsizeSolutionStoreServer interface {
	// Problem/Solution management
	ReadProblem(context.Context, *ReadProblemRequest) (*ProblemIdentifier, error)
	CreateSolution(context.Context, *ProblemIdentifier) (*ProblemEntityIdentifier, error)
	// Solution Improvement
	GetProblem(context.Context, *ProblemIdentifier) (*Problem, error)
	GetMachine(context.Context, *ProblemEntityIdentifier) (*Machine, error)
	GetDemandsForBucket(*ProblemBucketIdentifier, LotsizeSolutionStore_GetDemandsForBucketServer) error
	GetSolutionsIDsList(context.Context, *ProblemIdentifier) (*IDsList, error)
	GetSolution(*ProblemEntityIdentifier, LotsizeSolutionStore_GetSolutionServer) error
	SolutionImprovementStart(context.Context, *ProblemEntityIdentifier) (*SolutionEntityIdentifier, error)
	SolutionImprovementColsAdded(context.Context, *SolutionEntityIdentifier) (*Int32Result, error)
	SolutionImprovementStop(context.Context, *SolutionEntityIdentifier) (*Int32Result, error)
	mustEmbedUnimplementedLotsizeSolutionStoreServer()
}

// UnimplementedLotsizeSolutionStoreServer must be embedded to have forward compatible implementations.
type UnimplementedLotsizeSolutionStoreServer struct {
}

func (UnimplementedLotsizeSolutionStoreServer) ReadProblem(context.Context, *ReadProblemRequest) (*ProblemIdentifier, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadProblem not implemented")
}
func (UnimplementedLotsizeSolutionStoreServer) CreateSolution(context.Context, *ProblemIdentifier) (*ProblemEntityIdentifier, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSolution not implemented")
}
func (UnimplementedLotsizeSolutionStoreServer) GetProblem(context.Context, *ProblemIdentifier) (*Problem, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProblem not implemented")
}
func (UnimplementedLotsizeSolutionStoreServer) GetMachine(context.Context, *ProblemEntityIdentifier) (*Machine, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMachine not implemented")
}
func (UnimplementedLotsizeSolutionStoreServer) GetDemandsForBucket(*ProblemBucketIdentifier, LotsizeSolutionStore_GetDemandsForBucketServer) error {
	return status.Errorf(codes.Unimplemented, "method GetDemandsForBucket not implemented")
}
func (UnimplementedLotsizeSolutionStoreServer) GetSolutionsIDsList(context.Context, *ProblemIdentifier) (*IDsList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSolutionsIDsList not implemented")
}
func (UnimplementedLotsizeSolutionStoreServer) GetSolution(*ProblemEntityIdentifier, LotsizeSolutionStore_GetSolutionServer) error {
	return status.Errorf(codes.Unimplemented, "method GetSolution not implemented")
}
func (UnimplementedLotsizeSolutionStoreServer) SolutionImprovementStart(context.Context, *ProblemEntityIdentifier) (*SolutionEntityIdentifier, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SolutionImprovementStart not implemented")
}
func (UnimplementedLotsizeSolutionStoreServer) SolutionImprovementColsAdded(context.Context, *SolutionEntityIdentifier) (*Int32Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SolutionImprovementColsAdded not implemented")
}
func (UnimplementedLotsizeSolutionStoreServer) SolutionImprovementStop(context.Context, *SolutionEntityIdentifier) (*Int32Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SolutionImprovementStop not implemented")
}
func (UnimplementedLotsizeSolutionStoreServer) mustEmbedUnimplementedLotsizeSolutionStoreServer() {}

// UnsafeLotsizeSolutionStoreServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LotsizeSolutionStoreServer will
// result in compilation errors.
type UnsafeLotsizeSolutionStoreServer interface {
	mustEmbedUnimplementedLotsizeSolutionStoreServer()
}

func RegisterLotsizeSolutionStoreServer(s grpc.ServiceRegistrar, srv LotsizeSolutionStoreServer) {
	s.RegisterService(&LotsizeSolutionStore_ServiceDesc, srv)
}

func _LotsizeSolutionStore_ReadProblem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadProblemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LotsizeSolutionStoreServer).ReadProblem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lsxcg.lss.LotsizeSolutionStore/ReadProblem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LotsizeSolutionStoreServer).ReadProblem(ctx, req.(*ReadProblemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LotsizeSolutionStore_CreateSolution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProblemIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LotsizeSolutionStoreServer).CreateSolution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lsxcg.lss.LotsizeSolutionStore/CreateSolution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LotsizeSolutionStoreServer).CreateSolution(ctx, req.(*ProblemIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _LotsizeSolutionStore_GetProblem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProblemIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LotsizeSolutionStoreServer).GetProblem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lsxcg.lss.LotsizeSolutionStore/GetProblem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LotsizeSolutionStoreServer).GetProblem(ctx, req.(*ProblemIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _LotsizeSolutionStore_GetMachine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProblemEntityIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LotsizeSolutionStoreServer).GetMachine(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lsxcg.lss.LotsizeSolutionStore/GetMachine",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LotsizeSolutionStoreServer).GetMachine(ctx, req.(*ProblemEntityIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _LotsizeSolutionStore_GetDemandsForBucket_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ProblemBucketIdentifier)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LotsizeSolutionStoreServer).GetDemandsForBucket(m, &lotsizeSolutionStoreGetDemandsForBucketServer{stream})
}

type LotsizeSolutionStore_GetDemandsForBucketServer interface {
	Send(*Demand) error
	grpc.ServerStream
}

type lotsizeSolutionStoreGetDemandsForBucketServer struct {
	grpc.ServerStream
}

func (x *lotsizeSolutionStoreGetDemandsForBucketServer) Send(m *Demand) error {
	return x.ServerStream.SendMsg(m)
}

func _LotsizeSolutionStore_GetSolutionsIDsList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProblemIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LotsizeSolutionStoreServer).GetSolutionsIDsList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lsxcg.lss.LotsizeSolutionStore/GetSolutionsIDsList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LotsizeSolutionStoreServer).GetSolutionsIDsList(ctx, req.(*ProblemIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _LotsizeSolutionStore_GetSolution_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ProblemEntityIdentifier)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LotsizeSolutionStoreServer).GetSolution(m, &lotsizeSolutionStoreGetSolutionServer{stream})
}

type LotsizeSolutionStore_GetSolutionServer interface {
	Send(*Column) error
	grpc.ServerStream
}

type lotsizeSolutionStoreGetSolutionServer struct {
	grpc.ServerStream
}

func (x *lotsizeSolutionStoreGetSolutionServer) Send(m *Column) error {
	return x.ServerStream.SendMsg(m)
}

func _LotsizeSolutionStore_SolutionImprovementStart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProblemEntityIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LotsizeSolutionStoreServer).SolutionImprovementStart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lsxcg.lss.LotsizeSolutionStore/SolutionImprovementStart",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LotsizeSolutionStoreServer).SolutionImprovementStart(ctx, req.(*ProblemEntityIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _LotsizeSolutionStore_SolutionImprovementColsAdded_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SolutionEntityIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LotsizeSolutionStoreServer).SolutionImprovementColsAdded(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lsxcg.lss.LotsizeSolutionStore/SolutionImprovementColsAdded",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LotsizeSolutionStoreServer).SolutionImprovementColsAdded(ctx, req.(*SolutionEntityIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _LotsizeSolutionStore_SolutionImprovementStop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SolutionEntityIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LotsizeSolutionStoreServer).SolutionImprovementStop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lsxcg.lss.LotsizeSolutionStore/SolutionImprovementStop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LotsizeSolutionStoreServer).SolutionImprovementStop(ctx, req.(*SolutionEntityIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

// LotsizeSolutionStore_ServiceDesc is the grpc.ServiceDesc for LotsizeSolutionStore service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LotsizeSolutionStore_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "lsxcg.lss.LotsizeSolutionStore",
	HandlerType: (*LotsizeSolutionStoreServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReadProblem",
			Handler:    _LotsizeSolutionStore_ReadProblem_Handler,
		},
		{
			MethodName: "CreateSolution",
			Handler:    _LotsizeSolutionStore_CreateSolution_Handler,
		},
		{
			MethodName: "GetProblem",
			Handler:    _LotsizeSolutionStore_GetProblem_Handler,
		},
		{
			MethodName: "GetMachine",
			Handler:    _LotsizeSolutionStore_GetMachine_Handler,
		},
		{
			MethodName: "GetSolutionsIDsList",
			Handler:    _LotsizeSolutionStore_GetSolutionsIDsList_Handler,
		},
		{
			MethodName: "SolutionImprovementStart",
			Handler:    _LotsizeSolutionStore_SolutionImprovementStart_Handler,
		},
		{
			MethodName: "SolutionImprovementColsAdded",
			Handler:    _LotsizeSolutionStore_SolutionImprovementColsAdded_Handler,
		},
		{
			MethodName: "SolutionImprovementStop",
			Handler:    _LotsizeSolutionStore_SolutionImprovementStop_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetDemandsForBucket",
			Handler:       _LotsizeSolutionStore_GetDemandsForBucket_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetSolution",
			Handler:       _LotsizeSolutionStore_GetSolution_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "lssproto/lssproto.proto",
}
